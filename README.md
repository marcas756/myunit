
# myunit - A Practical Approach to Unit Testing

This project initially forked from the well-regarded uCUnit framework. While building upon its foundation, significant modifications were made to better suit specific needs, particularly regarding output options and the assertion macros themselves.  To clearly differentiate it from the original, I renamed it to myunit.

myunit is a collection of macros tailored for embedded systems, enabling the definition, execution, and validation of unit tests. Implemented in C, it provides macros for a range of test functionalities, such as memory comparisons, value checks, and checkpoint validations. The macros are designed to support configurable verbosity levels for test logging and can be adapted to platform-specific needs. myunit is not a complete framework but rather a lightweight toolset focused on facilitating unit tests for low-level functionality in environments with limited resources. The primary functionality centers around assertion macros, rather than a complete suite of tools for managing the entire unit testing process.

## Example: Writing and Running a Basic Unit Test

This code provides an example of a simple unit test within a test suite using myunit. The test suite, named `selftest`, includes a single test case called `test_assert`. This test case is designed to demonstrate the use of assertions to validate conditions and highlight how the framework handles both passing and failing tests.


```c
#include "myunit.h"


MYUNIT_TESTCASE(test_assert)
{
    // Test case description: This test case demonstrates a passing and a failing example of assertions.
    // The assertions will check simple conditions for equality and inequality.

    // Passing Assertion:
    // Test that 1 + 1 equals 2. This is expected to pass.
    MYUNIT_ASSERT("Check if 1 + 1 equals 2", (1 + 1 == 2));

    // Failing Assertion:
    // Test that 1 + 1 equals 3. This is expected to fail.
    MYUNIT_ASSERT("Check if 1 + 1 equals 3", (1 + 1 == 3));
}



void myunit_testsuite_setup() {}

void myunit_testsuite_teardown() {}

MYUNIT_TESTSUITE(selftest)
{
    MYUNIT_TESTSUITE_BEGIN();

    MYUNIT_EXEC_TESTCASE(test_assert);
    // Add more unit tests here

    MYUNIT_TESTSUITE_END();
}
```
The `test_assert` function defines two assertions. The first checks if the condition `1 + 1 == 2` is true, which will pass without issue. The second assertion checks if `1 + 1 == 3`, a condition that is clearly false. This failing assertion triggers the framework’s failure handling mechanism, which logs details about the failure, such as the test case name, the line number, and the provided message.

Before the test suite begins execution, the setup function `myunit_testsuite_setup` is called. Although empty in this example, it could be used to initialize any required resources. Similarly, after the test suite finishes, the teardown function `myunit_testsuite_teardown` is called to clean up resources.

When the test suite runs, it initializes with `MYUNIT_TESTSUITE_BEGIN()`, executes the `test_assert` test case with `MYUNIT_EXEC_TESTCASE(test_assert)`, and finalizes with `MYUNIT_TESTSUITE_END()`. The framework logs the results of the assertions, indicating which tests passed and which failed, and provides a summary at the end of the test suite execution. This process demonstrates the workflow for running unit tests, validating assertions, and reporting results.

```
<TSB> selftest "../src/myunit_selftest.c" "Nov 15 2024" "14:49:45"
<TCB> selftest test_assert
<TCP> selftest test_assert 11 "Check if 1 + 1 equals 2" "(1 + 1 == 2)"
<TCF> selftest test_assert 15 "Check if 1 + 1 equals 3" "(1 + 1 == 3)"
<TCE> selftest test_assert 1 1
<TSE> selftest 1 1 0 1
```

This output is generated by running the `selftest` test suite with the default verbosity level. It provides detailed information about the execution of the test suite, including test case progress and assertion results. The date and time displayed in the output reflect the compilation time of the test suite, as embedded by the compiler.

The first line, `<TSB>`, marks the start of the test suite `selftest`. It includes the name of the test suite (`selftest`), the source file where it is defined (`../src/myunit_selftest.c`), and the date and time when the test suite was compiled (`Nov 15 2024`, `14:49:45`).

The `<TCB>` line indicates the beginning of the test case `test_assert`, signaling that the framework has started executing this specific test case.
`<TCP>` represents a successful assertion. The test case `test_assert` verified that `1 + 1 == 2` at line 11. The associated message `"Check if 1 + 1 equals 2"` and the condition `"(1 + 1 == 2)"` are logged.
`<TCF>` represents a failing assertion. The test case `test_assert` checked the condition `1 + 1 == 3` at line 15, which failed. The message `"Check if 1 + 1 equals 3"` and the condition `"(1 + 1 == 3)"` are recorded.

The `<TCE>` line marks the end of the test case `test_assert`. The numbers `1 1` indicate that there was one successful assertion and one failed assertion within this test case.

Finally, `<TSE>` signifies the end of the test suite `selftest`. It summarizes the overall results as
- `1` failed test case,
- `1` failed assertion,
- `0` successful test cases,
- `1` successful assertion.

## Verbosity Levels in myunit

The `myunit` testing framework provides flexible verbosity levels to control the amount and type of output generated during test execution. This allows developers to adjust the feedback they receive based on their specific needs, ranging from completely silent operation to highly detailed reporting.

Verbosity levels are configured using predefined constants. These constants determine both the level of detail and whether assertion results are included in the output.


| **Constant**                    | **Value** | **Description**                                                                                   |
|----------------------------------|-----------|---------------------------------------------------------------------------------------------------|
| `MYUNIT_SILENT`                 | `0`       | No output. The framework operates in complete silence.                                           |
| `MYUNIT_VERB1_NO_ASSERTS`       | `1`       | Normal output; assertions are not included in the logs.                                          |
| `MYUNIT_VERB1_FAILED_ASSERTS`   | `2`       | Normal output; only failed assertions are printed.                                               |
| `MYUNIT_VERB1_ALL_ASSERTS`      | `3`       | Normal output; all assertions, whether successful or failed, are printed.                       |
| `MYUNIT_VERB2_NO_ASSERTS`       | `4`       | Detailed output; assertions are not included in the logs.                                        |
| `MYUNIT_VERB2_FAILED_ASSERTS`   | `5`       | Detailed output; only failed assertions are printed, along with additional contextual details.   |
| `MYUNIT_VERB2_ALL_ASSERTS`      | `6`       | Detailed output; all assertions, whether successful or failed, are printed with contextual details. |
| `MYUNIT_VERB3_NO_ASSERTS`       | `7`       | Extensive output; assertions are not included in the logs, but in-depth debugging information is provided. |
| `MYUNIT_VERB3_FAILED_ASSERTS`   | `8`       | Extensive output; only failed assertions are printed, with in-depth debugging information.       |
| `MYUNIT_VERB3_ALL_ASSERTS`      | `9`       | Extensive output; all assertions, whether successful or failed, are printed with maximum detail. |

### Setting the MYUNIT_VERBOSE Level at Compiler Invocation

To configure the verbosity level during compilation, you can define the MYUNIT_VERBOSE macro directly in the compiler's invocation command. This allows you to dynamically control the verbosity level without modifying the source code. The exact method for setting compiler macros depends on the compiler or toolchain being used, so you should refer to the user manual of your specific compiler/linker suite for detailed instructions.

For example, using GCC, you can define the verbosity level as follows (see -D only):

```
gcc -DMYUNIT_VERBOSE=MYUNIT_VERB1_ALL_ASSERTS -O0 -g3 -Wall -c -fmessage-length=0 -MMD -MP -MF"src/myunit_selftest.d" -MT"src/myunit_selftest.o" -o "src/myunit_selftest.o" "../src/myunit_selftest.c"
```

### Verbosity Levels: MYUNIT_VERB*_NO_ASSERTS

The MYUNIT_VERB*_NO_ASSERTS verbosity levels (MYUNIT_VERB1_NO_ASSERTS, MYUNIT_VERB2_NO_ASSERTS, or MYUNIT_VERB3_NO_ASSERTS) are designed for scenarios where assertion results are not included in the output. These levels provide a streamlined output, focusing only on the structure and results of the test execution, while excluding any details about individual assertions.

```
<TSB> selftest "../src/myunit_selftest.c" "Nov 15 2024" "19:43:32"
<TCB> selftest test_assert
<TCE> selftest test_assert 1 1
<TSE> selftest 1 1 0 1
```
### Verbosity Levels: MYUNIT_VERB*_FAILED_ASSERTS

The FAILED_ASSERTS verbosity levels (MYUNIT_VERB1_FAILED_ASSERTS, MYUNIT_VERB2_FAILED_ASSERTS, or MYUNIT_VERB3_FAILED_ASSERTS) are designed to provide feedback focusing exclusively on failed assertions. This minimizes noise by suppressing information about successful assertions, making it easier to locate and address issues during testing. 

```
<TSB> selftest "../src/myunit_selftest.c" "Nov 15 2024" "19:46:11"
<TCB> selftest test_assert
<TCF> selftest test_assert 15 "Check if 1 + 1 equals 3" "(1 + 1 == 3)"
<TCE> selftest test_assert 1 1
<TSE> selftest 1 1 0 1
```

### Verbosity Levels: MYUNIT_VERB*_ALL_ASSERTS

When the verbosity level is set to one of the *_ALL_ASSERTS constants (MYUNIT_VERB1_ALL_ASSERTS, MYUNIT_VERB2_ALL_ASSERTS, or MYUNIT_VERB3_ALL_ASSERTS), the output includes all assertion results, whether they pass or fail. This is the most transparent level of reporting for assertions, providing detailed insight into every check performed during testing.

```
<TSB> selftest "../src/myunit_selftest.c" "Nov 15 2024" "19:49:42"
<TCB> selftest test_assert
<TCP> selftest test_assert 11 "Check if 1 + 1 equals 2" "(1 + 1 == 2)"
<TCF> selftest test_assert 15 "Check if 1 + 1 equals 3" "(1 + 1 == 3)"
<TCE> selftest test_assert 1 1
<TSE> selftest 1 1 0 1
```

### Assertion Detail Levels: MYUNIT_VERB3_*_ASSERTS

At the VERB3 verbosity level, the output provides extensive details about each assertion, including the test suite, unit test name, line number in the source code, the assertion's text message, and the evaluated test condition. This information is presented for both passed and failed assertions, offering maximum context for debugging and analysis.

```
<TAG> TEST_SUITE TEST_NAME LINE_NUMBER "ASSERTION_MESSAGE" "(TEST_CONDITION)"

<TCP> selftest test_assert 11 "Check if 1 + 1 equals 2" "(1 + 1 == 2)"
<TCF> selftest test_assert 15 "Check if 1 + 1 equals 3" "(1 + 1 == 3)"
```

### Assertion Detail Levels: MYUNIT_VERB2_*_ASSERTS 

The VERB2 verbosity level provides detailed information about test assertions, including their result, test suite name, unit test name, line number in the source code, and a descriptive text message explaining the assertion. However, this level omits the explicit evaluation of the test condition, offering a balance between detail and conciseness.


```
<TAG> TEST_SUITE TEST_NAME LINE_NUMBER "ASSERTION_MESSAGE"

<TCP> selftest test_assert 11 "Check if 1 + 1 equals 2"
<TCF> selftest test_assert 15 "Check if 1 + 1 equals 3"
```

### Assertion Detail Levels: MYUNIT_VERB1_*_ASSERTS 

At the VERB1 verbosity level, the output provides a concise summary of assertions, focusing on test results with minimal additional information. Each line logs the result of an assertion, including the test suite name, the unit test name, and the line number of the assertion in the source code.

```
<TAG> TEST_SUITE TEST_NAME LINE_NUMBER

<TCP> selftest test_assert 11
<TCF> selftest test_assert 15
```

### Managing Initialization: Global vs. Suite-Specific

To port myunit to a new platform, you need to implement three essential platform-specific functions. These functions enable myunit to interact with platform hardware and provide the necessary infrastructure for running tests. 

Test suites in myunit are collections of test cases, each located within a single C module containing a main function (as defined by the `MYUNIT_TESTSUITE(...)` macro). The `myunit_platform_init` and `myunit_platform_deinit` functions serve as a common base initialization and cleanup for all test suites, handling tasks like setting up the clock system or configuring the UART for proper operation, which are required globally. In contrast, the `myunit_testsuite_setup` and `myunit_testsuite_teardown` functions are specific to each test suite and handle initialization and cleanup tasks unique to that suite. For instance, a test suite focused on encryption might use these functions to initialize encryption-specific hardware that is not required by other suites. This separation ensures that platform-level resources are initialized once for all suites, while test suite-specific setup is handled independently to cater to the unique requirements of each suite.

The `myunit_platform_init()` function is responsible for initializing platform-specific resources essential for running unit tests. This may include setting up peripherals such as UART for debug output, configuring GPIO or LEDs for test status indication, or preparing clocks and other hardware resources required for the test environment. It is important to ensure that all necessary peripherals are correctly initialized and to include error-handling mechanisms to detect and address initialization failures, ensuring the platform is fully prepared for testing.

```c
void myunit_platform_init() {
    // Example for STM32:
    HAL_Init();             // Initialize the HAL library.
    SystemClock_Config();   // Configure the system clock.
    MX_USART2_UART_Init();  // Initialize UART for logging.
}
```

The `myunit_platform_deinit()` function is responsible for cleaning up or deinitializing any resources initialized by `myunit_platform_init()`, ensuring the platform returns to a clean state after tests are completed. Typical use cases include closing communication interfaces, resetting peripherals, freeing memory resources, and powering down hardware used exclusively for testing. For proper implementation, ensure that each resource initialized in `myunit_platform_init()` has a corresponding deinitialization step and include checks to safely release resources without causing unintended side effects.

```c
void myunit_platform_deinit() {
    // Example for STM32:
    HAL_UART_DeInit(&huart2);  // Deinitialize UART.
    HAL_DeInit();              // Deinitialize the HAL library.
}

```

The `myunit_platform_printf(const char *format, ...)` function provides a platform-specific implementation for formatted output, crucial for logging test results and messages. It typically redirects formatted strings to a UART, console, or other debug interfaces, enabling debugging and monitoring. Common use cases include sending test logs to a serial terminal, writing them to a file, or utilizing ITM (Instrumentation Trace Macrocell) for ARM-based systems. Its implementation often leverages a standard library function like vsnprintf to format strings, which are then adapted to the platform's communication mechanism, such as UART transmission or ITM logging.


```c


int myunit_platform_printf ( const char * format, ... )
{
    va_list arglist;
    va_start( arglist, format );
    int retval = vprintf( format, arglist );
    va_end( arglist );
    return retval;
}
```

### Overview of Assertion Macros

myunit includes a variety of assertion macros to help you validate conditions during unit testing. These macros let you check logical conditions, compare memory blocks, verify variable values, test ranges, and assess bit states or checkpoints. With these specialized assertions, you can write clear and concise tests that cover a wide range of scenarios without unnecessary complexity. This section explains the purpose of each macro and how you can use it in your tests.

The MYUNIT_ASSERT macro is the core assertion, used to validate a logical condition and provide a descriptive message for better traceability. It takes two parameters: message, a string explaining the purpose of the assertion, and test, a boolean expression to be evaluated. If the condition evaluates to true, the assertion passes; otherwise, it fails, logging the failure details, including the message, test case name, file, and line number. This macro is versatile and serves as the foundation for all other specialized assertions in the framework. It ensures clear, concise tests and simplifies debugging by offering meaningful context for each assertion.	

#### Validating Logical Conditions with MYUNIT_ASSERT

The `MYUNIT_ASSERT(message, test)` macro is the foundation of the myunit framework, validating a logical condition and providing detailed feedback. It accepts two parameters: `message`, a descriptive string explaining the test's purpose, and `test`, a boolean expression to evaluate. If the condition evaluates to `true`, the assertion passes; otherwise, it fails, and the framework logs the failure with details in the format `<TAG> TEST_SUITE TEST_NAME LINE_NUMBER "ASSERTION_MESSAGE" "(TEST_CONDITION)"`. This output includes the suite and test case name, source file line number, and both the assertion message and condition, ensuring clarity and traceability for debugging. The macro is versatile and serves as the basis for all other assertions in the framework. 

```c
    MYUNIT_ASSERT("Check if 2 + 2 equals 4", (2 + 2 == 4));  // Passes
    MYUNIT_ASSERT("Check if 2 + 2 equals 5", (2 + 2 == 5));  // Fails
```

#### Validating Memory Contents with Assertion Macros

The `MYUNIT_ASSERT_MEM_EQUAL` and `MYUNIT_ASSERT_MEM_DIFFERENT` macros are designed to help you validate memory contents during unit testing. With `MYUNIT_ASSERT_MEM_EQUAL`, you can check that two memory blocks are identical byte-for-byte over a specified size, ensuring the accuracy of operations like serialization, buffer handling, or data transfers. In contrast, `MYUNIT_ASSERT_MEM_DIFFERENT` lets you verify that two memory blocks differ, which is useful for confirming uniqueness, randomness, or avoiding duplication. Both macros provide detailed feedback if a check fails, making it easier for you to debug and ensure the correctness of low-level memory operations.

```c
    uint8_t buffer1[5] = {0x01, 0x02, 0x03, 0x04, 0x05};
    uint8_t buffer2_equal[5] = {0x01, 0x02, 0x03, 0x04, 0x05};
    uint8_t buffer2_different[5] = {0x01, 0xFF, 0x03, 0x04, 0x05};

    // Assert that buffer1 and buffer2_equal are identical
    MYUNIT_ASSERT_MEM_EQUAL(buffer1, buffer2_equal, sizeof(buffer1));
    // Assert that buffer1 and buffer2_different are not identical
    MYUNIT_ASSERT_MEM_DIFFERENT(buffer1, buffer2_different, sizeof(buffer1));
```
This combined example demonstrates how to use both `MYUNIT_ASSERT_MEM_EQUAL` and `MYUNIT_ASSERT_MEM_DIFFERENT` to validate identical and differing memory blocks within a single test case.

#### Validating Value Comparisons with Assertion Macros

The MYUNIT_ASSERT_VAL_EQUAL and MYUNIT_ASSERT_VAL_DIFFERENT macros are designed to validate the equality or inequality of two variable values during unit testing. With MYUNIT_ASSERT_VAL_EQUAL, you can confirm that two variables hold the same value, ensuring that the expected and actual results of an operation match. Conversely, MYUNIT_ASSERT_VAL_DIFFERENT checks that two variables differ, which is useful for testing scenarios where distinct outcomes are required. These macros provide clear, detailed feedback if a check fails, making it easier to debug and verify the correctness of computations or logic in your code.

```c
    // Assert that 10 and 10 are equal
    MYUNIT_ASSERT_VAL_EQUAL(10, 10);
    // Assert that 10 and 20 are not equal
    MYUNIT_ASSERT_VAL_DIFFERENT(10, 20);
```

This example shows how to use `MYUNIT_ASSERT_VAL_EQUAL` to confirm that two literal values are equal and `MYUNIT_ASSERT_VAL_DIFFERENT` to verify that two literal values are distinct. These macros help ensure correctness in value comparisons during unit testing.


#### Validating Variable Ranges with Assertion Macros

The `MYUNIT_ASSERT_RANGE` macro is designed to validate whether a given variable falls within a specified range, inclusive of the minimum and maximum boundaries. It accepts three parameters: the variable to check (`var`), the lower bound (`min`), and the upper bound (`max`). If the variable's value is within the defined range, the assertion passes; otherwise, it fails and provides detailed feedback about the failure, including the variable’s actual value and the expected range. This macro is particularly useful for scenarios where constraints on variable values are critical, such as validating sensor readings, user input, or computed results.



```c
    // Assert that 15 is within the range [10, 20]
    MYUNIT_ASSERT_RANGE(15, 10, 20);
    // Assert that 25 is not within the range [10, 20] (this will fail)
    MYUNIT_ASSERT_RANGE(25, 10, 20);
```

This example demonstrates how `MYUNIT_ASSERT_RANGE` can be used to validate that a value falls within a specific range, ensuring correctness in cases where values must adhere to predefined boundaries.

The `MYUNIT_ASSERT_RANGE_INT8`, `MYUNIT_ASSERT_RANGE_UINT8`, `MYUNIT_ASSERT_RANGE_INT16`, `MYUNIT_ASSERT_RANGE_UINT16`, `MYUNIT_ASSERT_RANGE_INT32`, and `MYUNIT_ASSERT_RANGE_UINT32` macros are designed to validate that a variable falls within the valid range of a specific integer type, with an added constraint: the variable to be checked must be of at least the next size integer type. For instance, when using `MYUNIT_ASSERT_RANGE_INT8`, the variable being tested should be at least `int16_t`, ensuring that any potential overflow or truncation is avoided when performing the range check. This requirement is particularly beneficial in preventing subtle bugs that can arise due to implicit type promotions or narrowing conversions during computations.

```c
    int16_t int8_check = -50;     // At least one size larger than int8_t
    uint16_t uint8_check = 200;  // At least one size larger than uint8_t
    int32_t int16_check = 30000; // At least one size larger than int16_t
    uint32_t uint16_check = 60000; // At least one size larger than uint16_t
    int64_t int32_check = 1000000; // At least one size larger than int32_t
    uint64_t uint32_check = 4000000000; // At least one size larger than uint32_t

    // Assert that int8_check is within the range of int8_t [-128, 127]
    MYUNIT_ASSERT_RANGE_INT8(int8_check);
    // Assert that uint8_check is within the range of uint8_t [0, 255]
    MYUNIT_ASSERT_RANGE_UINT8(uint8_check);
    // Assert that int16_check is within the range of int16_t [-32,768, 32,767]
    MYUNIT_ASSERT_RANGE_INT16(int16_check);
    // Assert that uint16_check is within the range of uint16_t [0, 65,535]
    MYUNIT_ASSERT_RANGE_UINT16(uint16_check);
    // Assert that int32_check is within the range of int32_t [-2,147,483,648, 2,147,483,647]
    MYUNIT_ASSERT_RANGE_INT32(int32_check);
    // Assert that uint32_check is within the range of uint32_t [0, 4,294,967,295]
    MYUNIT_ASSERT_RANGE_UINT32(uint32_check);
```

By requiring the variable to be of at least the next larger size, these macros ensure safe and reliable validation without risking overflows or truncation.


#### Validating Bit States with Assertion Macros

The `MYUNIT_ASSERT_BIT_CLR` and `MYUNIT_ASSERT_BIT_SET` macros are used to validate the state of specific bits in a variable during unit testing. These macros take two parameters: `var`, the variable to check, and `pos`, the bit position (starting from 0). `MYUNIT_ASSERT_BIT_CLR` ensures that the bit at the specified position is cleared (set to 0), while `MYUNIT_ASSERT_BIT_SET` checks that the bit is set (set to 1). These macros are particularly useful for testing low-level hardware interactions, bit flags, or configuration registers, providing detailed feedback if the asserted bit state does not match the expected state.

```c
    uint8_t var = 0b10101010;
    // Assert that bit 0 (position 0) is cleared (0)
    MYUNIT_ASSERT_BIT_CLR(var, 0);
    // Assert that bit 7 (position 7) is set (1)
    MYUNIT_ASSERT_BIT_SET(var, 7);
```

These macros make it easy to test individual bit states, ensuring correctness in scenarios involving bit manipulation or hardware-level programming.


#### Validating Checkpoint States with Assertion Macros

The `MYUNIT_ASSERT_CHECKPOINT_PASSED` and `MYUNIT_ASSERT_CHECKPOINT_MISSED` macros validate the status of specific checkpoints during unit testing. These macros work with the checkpoint bit array, where each bit corresponds to a unique checkpoint.

```c
    // Assert that checkpoint 3 has been passed
    MYUNIT_ASSERT_CHECKPOINT_PASSED(3);
    // Assert that checkpoint 4 has been missed
    MYUNIT_ASSERT_CHECKPOINT_MISSED(4);
```

For a more comprehensive explanation of checkpoints, including their initialization and manipulation, refer to the checkpoints section.


### Using Checkpoints for Test Flow Validation

Checkpoints are used to track specific conditions or states during unit tests. They are useful for verifying whether certain code paths or critical operations were executed during a test. By setting, clearing, or checking the state of checkpoints, you can gain precise control over the test flow and assert expected behaviors at specific points.

Checkpoints are implemented as a bit array, where each bit represents a single checkpoint. The array's size determines the number of checkpoints available. Setting, clearing, or checking a checkpoint involves manipulating the corresponding bit in the array. This design ensures efficient memory usage and fast operations, even on resource-constrained platforms.

The macro `MYUNIT_CHECKPOINTS_INIT()` initializes the entire checkpoint bit array, clearing all bits to indicate that no checkpoints have been passed. It is typically called at the beginning of a test case to ensure that the checkpoints start in a clean state. Here's an example:

```c
    // Initialize all checkpoints at the start of the test
    MYUNIT_CHECKPOINTS_INIT();
```

This ensures a predictable and consistent starting point for checkpoint testing.

You can set or clear specific checkpoints in the bit array using the macros `MYUNIT_CHECKPOINT_SET(bit)` and `MYUNIT_CHECKPOINT_CLR(bit)`.

```c
    // Set checkpoint 3 as passed
    MYUNIT_CHECKPOINT_SET(3);
    // Clear checkpoint 3 (mark it as missed)
    MYUNIT_CHECKPOINT_CLR(3);
```

`MYUNIT_CHECKPOINT_SET(bit)` sets the specified bit (marking the corresponding checkpoint as passed),  while `MYUNIT_CHECKPOINT_CLR(bit)` clears the specified bit (marking the corresponding checkpoint as missed). It is recommended to define an enumeration for your checkpoints to assign meaningful and descriptive names, avoiding the use of arbitrary magic numbers.

To verify the state of a specific checkpoint, you can use the macros `MYUNIT_CHECKPOINT_PASSED(bit)` and `MYUNIT_CHECKPOINT_MISSED(bit)`.

```c
    if (MYUNIT_CHECKPOINT_PASSED(3)) 
    {
        // Do something if checkpoint 3 has passed
    }

    if (MYUNIT_CHECKPOINT_MISSED(4)) 
    {
        // Handle the case where checkpoint 4 was missed
    }
```

`MYUNIT_CHECKPOINT_PASSED(bit)` returns true if the specified checkpoint is marked as passed (bit is set), while `MYUNIT_CHECKPOINT_MISSED(bit` returns true if the specified checkpoint is marked as missed (bit is cleared).
However, as a writer of unit tests, you typically use the higher-level assertion macros `MYUNIT_ASSERT_CHECKPOINT_PASSED(idx)` and `MYUNIT_ASSERT_CHECKPOINT_MISSED(idx)` to integrate checkpoint validation into your tests more seamlessly.

```c
    // Assert that checkpoint 3 has been passed
    MYUNIT_ASSERT_CHECKPOINT_PASSED(3);

    // Assert that checkpoint 4 has been missed
    MYUNIT_ASSERT_CHECKPOINT_MISSED(4);
```

### Understanding Tags
Tags (`<...>`) are structured markers used to generate consistent, machine-readable output during test execution. These tags provide key information about the progress and results of test suites and cases, including details about assertions, failures, and summaries. Each tag follows a predefined format, making it easy to parse and analyze the output programmatically or manually.

   - `<TSB>`: Marks the beginning of a test suite. Includes the suite name, source file, and timestamp.
   - `<TSE>`: Marks the end of a test suite. Includes a summary of passed and failed test cases.
   - `<TCB>`: Marks the beginning of a test case. Includes the test case name.
   - `<TCE>`: Marks the end of a test case. Summarizes the results of assertions in the test case.
   - `<TCP>`: Indicates a passed assertion. Includes the test suite name, test case name, line number, assertion message, and evaluated condition.
   - `<TCF>`: Indicates a failed assertion. Provides the same details as `<TCP>`, along with information about the failure.

```plaintext
<TSB> selftest "../src/myunit_selftest.c" "Nov 15 2024" "19:49:42" <\n>
<TCB> selftest test_assert <\n>
<TCP> selftest test_assert 11 "Check if 2 + 2 equals 4" "(2 + 2 == 4)" <\n>
<TCF> selftest test_assert 15 "Check if 2 + 2 equals 5" "(2 + 2 == 5)" <\n>
<TCE> selftest test_assert 1 1 <\n>
<TSE> selftest 1 1 0 1 <\n>
```

Tags are delimited by a newline character, represented as `<\n>`. This signifies the end of each tag's information; for example, `<TSB> ... <\n>` indicates the complete tag. This newline separation is crucial for parsing and interpreting test results programmatically.

Tags provide detailed information about where and why a test passed or failed, including the line number and test message. The structured format allows for easy parsing by scripts or tools, enabling integration with continuous integration (CI) systems. The standardized output format ensures that both humans and machines can interpret the results consistently.




